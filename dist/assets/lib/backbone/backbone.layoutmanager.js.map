{"version":3,"sources":["assets/lib/backbone/backbone.layoutmanager.js"],"names":["window","keys","Backbone","_","$","_configure","View","prototype","LayoutManager","render","extend","constructor","options","setupView","this","call","swapLayout","newLayout","views","defaults","setElement","el","insertView","selector","view","setView","insertViews","each","concat","setViews","getView","fn","getViews","first","value","chain","map","flatten","filter","identity","name","append","partials","root","isString","isArray","remove","_options","__manager__","done","renderCallback","keep","manager","hasRendered","partial","delegateEvents","handler","resolveWith","viewDeferred","isFunction","deferred","_removeView","then","promise","parent","indexOf","push","renderDeferred","callback","_render","_viewRender","fetch","promises","seqRender","length","shift","def","clone","resolve","when","cleanViews","_remove","apply","arguments","_cache","_makeAsync","async","_isAsync","context","contents","cache","url","html","template","serialize","isObject","bind","prefix","unbind","cleanup","path","configure","opts","manage","viewOptions","proto","viewOverrides","pick","Layout","paths","layout","values","events","beforeRender","afterRender","trigger","findRootParent","on","off","isBoolean","i","splice","method","backboneProto","layoutProto","LayoutView","retVal","Deferred","$root","find"],"mappings":"CAKA,SAAUA,GAEV,YAGA,IAAIC,GAGAC,EAAWF,EAAOE,SAClBC,EAAIH,EAAOG,EACXC,EAAIJ,EAAOI,EAGXC,EAAaH,EAASI,KAAKC,UAAUF,WAIrCG,GAHSN,EAASI,KAAKC,UAAUE,OAGjBP,EAASI,KAAKI,QAEhCC,YAAa,SAAgBC,GAE3BA,EAAUA,MAGVJ,EAAcK,UAAUC,KAAMF,GAG9BV,EAASI,KAAKS,KAAKD,KAAMF,IAI3BI,WAAY,SAASC,GAQnB,MANAA,GAAUC,MAAQf,EAAEgB,YAAaL,KAAKI,MAAOD,EAAUC,OAGvDD,EAAUG,WAAWN,KAAKO,IAGnBJ,GAITK,WAAY,SAASC,EAAUC,GAE7B,MAAIA,GACKV,KAAKW,QAAQF,EAAUC,GAAM,GAI/BV,KAAKW,QAAQF,GAAU,IAIhCG,YAAa,SAASR,GAMpB,MAJAf,GAAEwB,KAAKT,EAAO,SAASM,EAAMD,GAC3BL,EAAMK,MAAeK,OAAOJ,KAGvBV,KAAKe,SAASX,IAIvBY,QAAS,SAASC,GAChB,MAAOjB,MAAKkB,SAASD,GAAIE,QAAQC,SAKnCF,SAAU,SAASD,GAEjB,GAAIb,GAAQf,EAAEgC,MAAMrB,KAAKI,OAAOkB,IAAI,SAASZ,GAC3C,SAAUI,OAAOJ,IAChBV,MAAMuB,UAAUH,OAGnB,OAAO/B,GAAEgC,MAAMhC,EAAEmC,OAAOpB,EAAOa,EAAKA,EAAK5B,EAAEoC,YAU7Cd,QAAS,SAASe,EAAMhB,EAAMiB,GAC5B,GAAIC,GAAU9B,EACV+B,EAAO7B,IAyFX,OAtFKX,GAAEyC,SAASJ,KACdC,EAASjB,EACTA,EAAOgB,EACPA,EAAO,IAIT1B,KAAKI,MAAQJ,KAAKI,WAGbuB,GAAU3B,KAAKI,MAAMsB,KAEpBrC,EAAE0C,QAAQ/B,KAAKI,MAAMsB,IACvBrC,EAAEwB,KAAKb,KAAKI,MAAMsB,GAAO,SAAShB,GAChCA,EAAKsB,WAIPhC,KAAKI,MAAMsB,GAAMM,UAKrBlC,EAAUY,EAAKuB,WAGVvB,EAAKwB,aACRxC,EAAcK,UAAUW,EAAMZ,GAIhCY,EAAKf,OAAS,SAASwC,GASrB,QAASC,KAGDT,IAAUjB,EAAK2B,MAAUC,EAAQC,aACrCzC,EAAQ0C,QAAQX,EAAKtB,GAAImB,EAAMhB,EAAKH,GAAIoB,GAI1CjB,EAAK+B,iBAGDH,EAAQI,UAEVJ,EAAQI,QAAQC,YAAYjC,GAAOA,EAAKH,WAGjC+B,GAAQI,SAKjBE,EAAaD,YAAYjC,GAAOA,EAAKH,KAGjClB,EAAEwD,WAAWV,IACfA,EAAKlC,KAAKS,EAAMA,EAAKH,IAjCzB,GAAIqC,GAAe9C,EAAQgD,WACvBR,EAAU5B,EAAKwB,WA2CnB,OAxCAI,GAAQM,aAAeA,EAkCvBlC,EAAKqC,cAGLrD,EAAcD,UAAUE,OAAOM,KAAKS,GAAMsC,KAAKZ,GAGxCQ,EAAaK,WAItBvC,EAAKwB,YAAYgB,OAASrB,EAE1BnB,EAAKwB,YAAYzB,SAAWiB,EAIxBC,GAEFC,EAAW5B,KAAKI,MAAMsB,GAAQ1B,KAAKI,MAAMsB,OAEpCrC,EAAE0C,QAAQ/B,KAAKI,MAAMsB,MAExBE,EAAW5B,KAAKI,MAAMsB,IAAS1B,KAAKI,MAAMsB,KAKxCrC,EAAE8D,QAAQvB,EAAUlB,IAAQ,EACvBA,GAITkB,EAASwB,KAAK1C,GAGdA,EAAKwB,YAAYP,QAAS,EAEnBjB,IAIFV,KAAKI,MAAMsB,GAAQhB,GAI5BK,SAAU,SAASX,GAejB,MAbAf,GAAEwB,KAAKT,EAAO,SAASM,EAAMgB,GAE3B,MAAIrC,GAAE0C,QAAQrB,GACLrB,EAAEwB,KAAKH,EAAM,SAASA,GAC3BV,KAAKQ,WAAWkB,EAAMhB,IACrBV,UAILA,MAAKW,QAAQe,EAAMhB,IAClBV,MAGIA,MASTL,OAAQ,SAASwC,GACf,GAAIN,GAAO7B,KACPF,EAAUE,KAAKiC,WACfW,EAAe9C,EAAQgD,UAG3B,OAAI9C,MAAKkC,YAAYmB,gBAEnBrD,KAAKkC,YAAYoB,SAAWnB,EAGrBnC,KAAKkC,YAAYmB,iBAI1BrD,KAAKuD,QAAQ7D,EAAc8D,aAAaC,MAAMT,KAAK,WAEjDnB,EAAKK,YAAYmB,eAAiBT,CAKlC,IAAIc,GAAWrE,EAAEiC,IAAIO,EAAKzB,MAAO,SAASM,GAKxC,QAASiD,GAAUvD,EAAO+B,GAGxB,IAAK/B,EAAMwD,OACT,MAAOzB,IAIT,IAAIzB,GAAON,EAAMyD,OAGjBnD,GAAKf,OAAO,WAGVgE,EAAUvD,EAAO+B,KAjBrB,GAAI2B,EAsBJ,OAAIzE,GAAE0C,QAAQrB,IAEZoD,EAAMhE,EAAQgD,WAEda,EAAUtE,EAAE0E,MAAMrD,GAAO,WACvBoD,EAAIE,YAGCF,EAAIb,WAKNvC,EAAKf,UAIdG,GAAQmE,KAAKP,GAAUV,KAAK,WAC1BJ,EAAaD,YAAYd,GAAOA,EAAKtB,SAMlCqC,EAAaI,KAAK,WAEnB3D,EAAEwD,WAAWV,IACfA,EAAKlC,KAAK4B,EAAMA,EAAKtB,IAGnBsB,EAAKK,YAAYQ,UACnBb,EAAKK,YAAYQ,QAAQC,YAAYd,GAAOA,EAAKtB,WAG1CsB,GAAKK,YAAYQ,SAMtBrD,EAAEwD,WAAWhB,EAAKK,YAAYoB,YAChCzB,EAAKK,YAAYoB,SAASrD,KAAK4B,EAAMA,EAAKtB,UAGnCsB,GAAKK,YAAYoB,gBAInBzB,GAAKK,YAAYmB,mBAK5BrB,OAAQ,WAIN,MAHAtC,GAAcwE,WAAWlE,MAGlBA,KAAKmE,QAAQC,MAAMpE,KAAMqE,YAIlCpC,SAAU,WAER,MAAO5C,GAAEO,UAAWI,KAAMN,EAAcD,UAAUK,QAASE,KAAKF,YAKlEwE,UAGAC,WAAY,SAASzE,EAASqC,GAC5B,GAAIO,GAAU5C,EAAQgD,UAStB,OANAJ,GAAQ8B,MAAQ,WAGd,MAFA9B,GAAQ+B,UAAW,EAEZtC,GAGFO,GAITc,YAAa,SAAS3B,GAOpB,QAASM,GAAKuC,EAASC,GAErBjF,EAAckF,MAAMC,EAAKF,GAGrBA,GACF7E,EAAQgF,KAAKjD,EAAKtB,GAAIT,EAAQH,OAAOgF,EAAUD,IAKjDhC,EAAQe,MAAMd,YAAYd,GAAOA,EAAKtB,KAjBxC,GAAIsE,GAAKF,EAAUjC,EACf5C,EAAU+B,EAAKI,UAmBnB,QAIEtC,OAAQ,SAAS+E,GACf,GAAIpC,GAAUT,EAAKK,YACf6C,EAAWlD,EAAKkD,UAAYjF,EAAQiF,QA+BxC,OA7BIlD,GAAKmD,YACPlF,EAAQkF,UAAYnD,EAAKmD,YAItBN,GAAWrF,EAAEwD,WAAW/C,EAAQkF,WACnCN,EAAU5E,EAAQkF,UAAU/E,KAAK4B,IAEvB6C,GAAWrF,EAAE4F,SAASnF,EAAQkF,aACxCN,EAAU5E,EAAQkF,WAIpBtC,EAAUhD,EAAc6E,WAAWzE,EAAST,EAAE6F,KAAK/C,EAAMN,EACvD6C,IAGFhC,EAAQe,MAAQ3D,EAAQgD,WAIxBR,EAAQI,QAAUA,EAGdrD,EAAEyC,SAASiD,KACbF,EAAMvC,EAAQ6C,OAASJ,IAIrBJ,EAAWjF,EAAckF,MAAMC,KACjC1C,EAAKuC,EAASC,EAAUE,GAEjBnC,IAILrD,EAAEyC,SAASiD,GACbJ,EAAW7E,EAAQ2D,MAAMxD,KAAKyC,EAASJ,EAAQ6C,OAASJ,GAEnC,MAAZA,IACTJ,EAAW7E,EAAQ2D,MAAMxD,KAAKyC,EAASqC,IAIpCrC,EAAQ+B,UACXtC,EAAKuC,EAASC,GAGTjC,MAObwB,WAAY,SAAS9D,GAEnBf,EAAEwB,QAAQC,OAAOV,GAAQ,SAASM,GAEhCA,EAAK0E,SAGD1E,EAAKN,OACPf,EAAEwB,KAAKH,EAAKN,MAAO,SAASM,GAC1BhB,EAAcwE,WAAWxD,KAMzBrB,EAAEwD,WAAWnC,EAAK2E,UACpB3E,EAAK2E,QAAQpF,KAAKS,MAMxBkE,MAAO,SAASU,EAAMX,GAEpB,MAAIW,KAAQtF,MAAKsE,OACRtE,KAAKsE,OAAOgB,GAEF,MAARA,GAA4B,MAAZX,EAClB3E,KAAKsE,OAAOgB,GAAQX,EADtB,QAQTY,UAAW,SAASC,GAClBnG,EAAEO,OAAOF,EAAcD,UAAUK,QAAS0F,GAGtCA,EAAKC,SACPrG,EAASI,KAAKC,UAAUgG,QAAS,IAKrC1F,UAAW,SAASW,EAAMZ,GACxB,GAAIM,GAAOsF,EACPC,EAAQvG,EAASM,cAAcD,UAC/BmG,EAAgBvG,EAAEwG,KAAKnF,EAAMvB,EAG7BuB,GAAKwB,cAKT7C,EAAEgB,SAASK,GAETN,SAIA8B,eAGAD,SAAUvC,EAAcD,UAAUwC,SAGlCc,YAAarD,EAAcqD,cAIzBrC,YAAgBtB,GAAS0G,OAC3BpF,EAAKwB,YAAYiD,OAASzE,EAAKuB,WAAW8D,MAAMC,QAAU,GAG1DtF,EAAKwB,YAAYiD,OAASzE,EAAKuB,WAAW8D,MAAMhB,UAAY,GAI9DjF,EAAUY,EAAKZ,QAAUT,EAAEgB,SAASP,MAAeY,EAAKZ,QACtD6F,EAAM7F,SAGR4F,EAAcrG,EAAEwG,KAAK/F,GAAU,UAAUgB,OAAOzB,EAAE4G,OAAOnG,EAAQoG,UACjE7G,EAAEO,OAAOc,EAAMgF,SAIRE,GAAcjG,OAIrBN,EAAEO,OAAOE,EAAS8F,GAGlBlF,EAAKyD,QAAU/E,EAASI,KAAKC,UAAUuC,OAGvCtB,EAAK6C,QAAU,SAASkC,GACtB,GAAIpC,GAEA8C,EAAenG,KAAKiC,WAAWkE,aAC/BC,EAAcpG,KAAKiC,WAAWmE,WA+ElC,OA5EApG,MAAK+C,cAGD1D,EAAEwD,WAAWsD,IACfA,EAAalG,KAAKD,KAAMA,MAI1BA,KAAKqG,QAAQ,eAAgBrG,MAG7BqD,EAAiBoC,EAAOzF,MAAML,SAG9B0D,EAAeL,KAAK,WAElB,GAAItC,GAAOV,KAEPsC,EAAU5B,EAAKwB,YAEfgB,EAASZ,EAAQY,OAGjBf,EAAO,WAETzB,EAAK+B,iBAGL/B,EAAKwB,YAAYK,aAAc,EAG3BlD,EAAEwD,WAAWuD,IACfA,EAAYnG,KAAKS,EAAMA,GAIzBA,EAAK2F,QAAQ,cAAe3F,IAI1B4F,EAAiB,SAAS5F,GAC5B,GAAI4B,GAAU5B,EAAKwB,WAGnB,OAAII,GAAQY,SAAWZ,EAAQC,YACtB+D,EAAehE,EAAQY,QAIzBxC,EAIT,OAAKwC,GAKDA,EAAOhB,YAAYK,YACdzC,EAAQmE,MAAM3B,EAAQM,aAAcM,EAAOhB,YAAYU,eAAeI,KAAK,WAChFb,EAAKlC,KAAKS,MAIdwC,EAASoD,EAAe5F,OAIxBwC,GAAOqD,GAAG,cAAe,WAEvBrD,EAAOsD,IAAI,KAAM,KAAM9F,GAGvByB,EAAKlC,KAAKS,IACTA,IApBMyB,EAAKlC,KAAKS,KAsBd2C,GAIT3C,EAAKf,OAASD,EAAcD,UAAUE,OAIlCe,EAAKsB,SAAW2D,EAAM3D,SACxBtB,EAAKyD,QAAUzD,EAAKsB,OACpBtB,EAAKsB,OAAS2D,EAAM3D,QAKtB5B,EAAQN,EAAQM,OAASM,EAAKN,MAG1Bf,EAAEF,KAAKiB,GAAOwD,QAChBlD,EAAKK,SAASX,GAIZM,EAAKqE,WACPjF,EAAQiF,SAAWrE,EAAKqE,eAGjBrE,GAAKqE,YAKhBhC,YAAa,SAASlB,GAEpBA,EAAOA,GAAQ7B,KAGf6B,EAAKX,WAAWL,KAAK,SAASH,GAE5B,GAAI4B,GAAU5B,EAAKwB,YAEfG,EAAOhD,EAAEoH,UAAU/F,EAAK2B,MAAQ3B,EAAK2B,KAAO3B,EAAKZ,QAAQuC,IAG7D,KAAKA,GAAQC,EAAQX,UAAW,GAAQW,EAAQC,YAAa,CAM3D,GAJA7B,EAAKsB,SAID3C,EAAE0C,QAAQO,EAAQY,OAAO9C,MAAMkC,EAAQ7B,WAEzC,MAAO6B,GAAQY,OAAOlC,QAAQ,SAASN,EAAMgG,GAEvChG,EAAKwB,YAAYzB,WAAa6B,EAAQ7B,UACxC6B,EAAQY,OAAO9C,MAAMkC,EAAQ7B,UAAUkG,OAAOD,EAAG,WAMhDpE,GAAQY,OAAOZ,EAAQ7B,gBAOtCpB,GAAEwB,MAAM,MAAO,MAAO,UAAW,SAAS+F,GACxC,GAAIC,GAAgBzH,EAASI,KAAKC,UAC9BqH,EAAcpH,EAAcD,SAGhCoH,GAAcD,EAAS,QAAUE,EAAYF,EAAS,QAGtDC,EAAcD,EAAS,SAAWE,EAAYF,EAAS,WAIzDxH,EAAS0G,OAAS1G,EAASM,cAAgBA,EAE3CN,EAAS2H,WAAa3H,EAASI,KAAKI,QAClC6F,QAAQ,IAKVrG,EAASI,KAAKC,UAAUF,WAAa,WAEnC,GAAIyH,GAASzH,EAAW6E,MAAMpE,KAAMqE,UASpC,OANIrE,MAAKyF,QAEP/F,EAAcK,UAAUC,MAInBgH,GAITtH,EAAcD,UAAUK,SAGtBiG,SAGAjD,SAAU,WACR,MAAOxD,GAAE2H,YAKXxD,MAAO,SAAS6B,GACd,MAAOjG,GAAE0F,SAASzF,EAAEgG,GAAMR,SAM5BtC,QAAS,SAASX,EAAMH,EAAMnB,EAAIoB,GAEhC,GAAIuF,GAAQxF,EAAOpC,EAAEuC,GAAMsF,KAAKzF,GAAQpC,EAAEuC,EAG1C,SAAKqF,EAAMtD,SAKX5D,KAAK2B,EAAS,SAAW,QAAQuF,EAAO3G,IAGjC,IAKTuE,KAAM,SAASjD,EAAMtB,GACnBjB,EAAEuC,GAAMiD,KAAKvE,IAIfoB,OAAQ,SAASE,EAAMtB,GACrBjB,EAAEuC,GAAMF,OAAOpB,IAIjB0D,KAAM,SAASP,GACb,MAAOpE,GAAE2E,KAAKG,MAAM,KAAMV,IAI5B/D,OAAQ,SAASoF,EAAUL,GACzB,MAAOK,GAASL,KAKpBvF,EAAOE,EAAEF,KAAKO,EAAcD,UAAUK,UAEnCE","file":"backbone.layoutmanager.js","sourcesContent":["/*!\n * backbone.layoutmanager.js v0.6.5\n * Copyright 2012, Tim Branyen (@tbranyen)\n * backbone.layoutmanager.js may be freely distributed under the MIT license.\n */\n(function(window) {\n\n\"use strict\";\n\n// Used to keep track of all LayoutManager key names.\nvar keys;\n\n// Alias the libraries from the global object.\nvar Backbone = window.Backbone;\nvar _ = window._;\nvar $ = window.$;\n\n// Store references to original View functions.\nvar _configure = Backbone.View.prototype._configure;\nvar render = Backbone.View.prototype.render;\n\n// A LayoutManager is simply a Backbone.View with some sugar.\nvar LayoutManager = Backbone.View.extend({\n  // This named function allows for significantly easier debugging.\n  constructor: function Layout(options) {\n    // Options should always a valid object.\n    options = options || {};\n\n    // Give this View superpowers.\n    LayoutManager.setupView(this, options);\n\n    // Have Backbone set up the rest of this View.\n    Backbone.View.call(this, options);\n  },\n\n  // Swap the current layout to  new layout.\n  swapLayout: function(newLayout) {\n    // Set Views to be a hybrid of original and new layout.\n    newLayout.views = _.defaults({}, this.views, newLayout.views);\n\n    // Re-use the same layout DOM element.\n    newLayout.setElement(this.el);\n\n    // Allow for chainability.\n    return newLayout;\n  },\n\n  // Shorthand to root.view function with append flag.\n  insertView: function(selector, view) {\n    // If a selector was passed, forward that onto setView.\n    if (view) {\n      return this.setView(selector, view, true);\n    }\n\n    // Omitting a selector will place the View directly into the parent.\n    return this.setView(selector, true);\n  },\n\n  // Works like insertView, except allows you to bulk insert via setViews.\n  insertViews: function(views) {\n    // Ensure each view is wrapped in an array.\n    _.each(views, function(view, selector) {\n      views[selector] = [].concat(view);\n    });\n\n    return this.setViews(views);\n  },\n\n  // Will return a single view that matches the filter function.\n  getView: function(fn) {\n    return this.getViews(fn).first().value();\n  },\n\n  // Provide a filter function to get a flattened array of all the subviews.\n  // If the filter function is omitted it will return all subviews.\n  getViews: function(fn) {\n    // Flatten all views.\n    var views = _.chain(this.views).map(function(view) {\n      return [].concat(view);\n    }, this).flatten().value();\n\n    // Return a wrapped function to allow for easier chaining.\n    return _.chain(_.filter(views, fn ? fn : _.identity));\n  },\n\n  // This takes in a partial name and view instance and assigns them to\n  // the internal collection of views.  If a view is not a LayoutManager\n  // instance, then mix in the LayoutManager prototype.  This ensures\n  // all Views can be used successfully.\n  //\n  // Must definitely wrap any render method passed in or defaults to a\n  // typical render function `return layout(this).render()`.\n  setView: function(name, view, append) {\n    var partials, options;\n    var root = this;\n\n    // If no name was passed, use an empty string and shift all arguments.\n    if (!_.isString(name)) {\n      append = view;\n      view = name;\n      name = \"\";\n    }\n\n    // If the parent View's object, doesn't exist... create it.\n    this.views = this.views || {};\n\n    // Ensure remove is called when swapping View's.\n    if (!append && this.views[name]) {\n      // If the views are an array, iterate and remove each individually.\n      if (_.isArray(this.views[name])) {\n        _.each(this.views[name], function(view) {\n          view.remove();\n        });\n      // Otherwise it's a single view and can safely call remove.\n      } else {\n        this.views[name].remove();\n      }\n    }\n\n    // Instance overrides take precedence, fallback to prototype options.\n    options = view._options();\n\n    // Set up the View, if it's not already managed.\n    if (!view.__manager__) {\n      LayoutManager.setupView(view, options);\n    }\n\n    // Custom template render function.\n    view.render = function(done) {\n      var viewDeferred = options.deferred();\n      var manager = view.__manager__;\n\n      // Ensure the latest deferred is assigned.\n      manager.viewDeferred = viewDeferred;\n      \n      // Break this callback out so that its not duplicated inside the \n      // following safety try/catch.\n      function renderCallback() {\n        // List items should not be re-added, unless they have `keep: true`\n        // set.\n        if ((!append || view.keep) || !manager.hasRendered) {\n          options.partial(root.el, name, view.el, append);\n        }\n\n        // Ensure events are always correctly bound after rendering.\n        view.delegateEvents();\n\n        // If the View has a managed handler, resolve and remove it.\n        if (manager.handler) {\n          // Resolve the View's render handler deferred.\n          manager.handler.resolveWith(view, [view.el]);\n\n          // Remove the handler once it has resolved.\n          delete manager.handler;\n        }\n\n        // When a view has been resolved, ensure that it is correctly updated\n        // and that any done callbacks are triggered.\n        viewDeferred.resolveWith(view, [view.el]);\n\n        // Only call the done function if a callback was provided.\n        if (_.isFunction(done)) {\n          done.call(view, view.el);\n        }\n      }\n\n      // Remove subViews without the `keep` flag set to `true`.\n      view._removeView();\n\n      // Call the original render method.\n      LayoutManager.prototype.render.call(view).then(renderCallback);\n\n      // Return the promise for chainability.\n      return viewDeferred.promise();\n    };\n\n    // Add reference to the parentView.\n    view.__manager__.parent = root;\n    // Add reference to the placement selector used.\n    view.__manager__.selector = name;\n\n    // Special logic for appending items. List items are represented as an\n    // array.\n    if (append) {\n      // Start with an array if none exists.\n      partials = this.views[name] = this.views[name] || [];\n      \n      if (!_.isArray(this.views[name])) {\n        // Ensure this.views[name] is an array.\n        partials = this.views[name] = [this.views[name]];\n      }\n\n      // Ensure the View is not already added to the list.  If it is, bail out\n      // early.\n      if (_.indexOf(partials, view) > -1) {\n        return view;\n      }\n\n      // Add the view to the list of partials.\n      partials.push(view);\n\n      // Put the view into `append` mode.\n      view.__manager__.append = true;\n\n      return view;\n    }\n\n    // Assign to main views object and return for chainability.\n    return this.views[name] = view;\n  },\n\n  // Allows the setting of multiple views instead of a single view.\n  setViews: function(views) {\n    // Iterate over all the views and use the View's view method to assign.\n    _.each(views, function(view, name) {\n      // If the view is an array put all views into insert mode.\n      if (_.isArray(view)) {\n        return _.each(view, function(view) {\n          this.insertView(name, view);\n        }, this);\n      }\n\n      // Assign each view using the view function.\n      this.setView(name, view);\n    }, this);\n\n    // Allow for chaining\n    return this;\n  },\n\n  // By default this should find all nested views and render them into\n  // the this.el and call done once all of them have successfully been\n  // resolved.\n  //\n  // This function returns a promise that can be chained to determine\n  // once all subviews and main view have been rendered into the view.el.\n  render: function(done) {\n    var root = this;\n    var options = this._options();\n    var viewDeferred = options.deferred();\n\n    // Ensure duplicate renders don't override.\n    if (this.__manager__.renderDeferred) {\n      // Set the most recent done callback.\n      this.__manager__.callback = done;\n\n      // Return the deferred.\n      return this.__manager__.renderDeferred;\n    }\n    \n    // Wait until this View has rendered before dealing with nested Views.\n    this._render(LayoutManager._viewRender).fetch.then(function() {\n      // Disable the ability for any new sub-views to be added.\n      root.__manager__.renderDeferred = viewDeferred;\n\n      // Create a list of promises to wait on until rendering is done. Since\n      // this method will run on all children as well, its sufficient for a\n      // full hierarchical. \n      var promises = _.map(root.views, function(view) {\n        // Hoist deferred var, used later on...\n        var def;\n\n        // Ensure views are rendered in sequence\n        function seqRender(views, done) {\n          // Once all views have been rendered invoke the sequence render\n          // callback.\n          if (!views.length) {\n            return done();\n          }\n\n          // Get each view in order, grab the first one off the stack.\n          var view = views.shift();\n\n          // Render the View and once complete call the next view.\n          view.render(function() {\n            // Invoke the recursive sequence render function with the\n            // remaining views.\n            seqRender(views, done);\n          });\n        }\n\n        // If rendering a list out, ensure they happen in a serial order.\n        if (_.isArray(view)) {\n          // A singular deferred that represents all the items.\n          def = options.deferred();\n\n          seqRender(_.clone(view), function() {\n            def.resolve();\n          });\n\n          return def.promise();\n        }\n\n        // Only return the fetch deferred, resolve the main deferred after\n        // the element has been attached to it's parent.\n        return view.render();\n      });\n\n      // Once all subViews have been rendered, resolve this View's deferred.\n      options.when(promises).then(function() {\n        viewDeferred.resolveWith(root, [root.el]);\n      });\n    });\n\n    // Return a promise that resolves once all immediate subViews have\n    // rendered.\n    return viewDeferred.then(function() {\n      // Only call the done function if a callback was provided.\n      if (_.isFunction(done)) {\n        done.call(root, root.el);\n      }\n\n      if (root.__manager__.handler) {\n        root.__manager__.handler.resolveWith(root, [root.el]);\n\n        // Remove the handler, so it's never accidentally referenced.\n        delete root.__manager__.handler;\n      }\n\n      // If the render was called twice, there is a possibility that the\n      // callback style was used twice.  This will ensure the latest callback\n      // is also triggered.\n      if (_.isFunction(root.__manager__.callback)) {\n        root.__manager__.callback.call(root, root.el);\n\n        // Remove the most recent callback.\n        delete root.__manager__.callback;\n      }\n\n      // Remove the rendered deferred.\n      delete root.__manager__.renderDeferred;\n    });\n  },\n\n  // Ensure the cleanup function is called whenever remove is called.\n  remove: function() {\n    LayoutManager.cleanViews(this);\n\n    // Call the original remove function.\n    return this._remove.apply(this, arguments);\n  },\n\n  // Merge instance and global options.\n  _options: function() {\n    // Instance overrides take precedence, fallback to prototype options.\n    return _.extend({}, this, LayoutManager.prototype.options, this.options);\n  }\n},\n{\n  // Clearable cache.\n  _cache: {},\n\n  // Creates a deferred and returns a function to call when finished.\n  _makeAsync: function(options, done) {\n    var handler = options.deferred();\n\n    // Used to handle asynchronous renders.\n    handler.async = function() {\n      handler._isAsync = true;\n\n      return done;\n    };\n\n    return handler;\n  },\n\n  // This gets passed to all _render methods.\n  _viewRender: function(root) {\n    var url, contents, handler;\n    var options = root._options();\n\n    // Once the template is successfully fetched, use its contents to\n    // proceed.  Context argument is first, since it is bound for\n    // partial application reasons.\n    function done(context, contents) {\n      // Ensure the cache is up-to-date.\n      LayoutManager.cache(url, contents);\n\n      // Render the View into the el property.\n      if (contents) {\n        options.html(root.el, options.render(contents, context));\n      }\n\n      // Resolve only the fetch (used internally) deferred with the View\n      // element.\n      handler.fetch.resolveWith(root, [root.el]);\n    }\n\n    return {\n      // This render function is what gets called inside of the View render,\n      // when manage(this).render is called.  Returns a promise that can be\n      // used to know when the element has been rendered into its parent.\n      render: function(context) {\n        var manager = root.__manager__;\n        var template = root.template || options.template;\n\n        if (root.serialize) {\n          options.serialize = root.serialize;\n        }\n\n        // Seek out serialize method and use that object.\n        if (!context && _.isFunction(options.serialize)) {\n          context = options.serialize.call(root);\n        // If serialize is an object, just use that.\n        } else if (!context && _.isObject(options.serialize)) {\n          context = options.serialize;\n        }\n\n        // Create an asynchronous handler.\n        handler = LayoutManager._makeAsync(options, _.bind(done, root,\n          context));\n\n        // Make a new deferred purely for the fetch function.\n        handler.fetch = options.deferred();\n\n        // Assign the handler internally to be resolved once its inside the\n        // parent element.\n        manager.handler = handler;\n\n        // Set the url to the prefix + the view's template property.\n        if (_.isString(template)) {\n          url = manager.prefix + template;\n        }\n\n        // Check if contents are already cached.\n        if (contents = LayoutManager.cache(url)) {\n          done(context, contents, url);\n\n          return handler;\n        }\n\n        // Fetch layout and template contents.\n        if (_.isString(template)) {\n          contents = options.fetch.call(handler, manager.prefix + template);\n        // If its not a string just pass the object/function/whatever.\n        } else if (template != null) {\n          contents = options.fetch.call(handler, template);\n        }\n\n        // If the function was synchronous, continue execution.\n        if (!handler._isAsync) {\n          done(context, contents);\n        }\n\n        return handler;\n      }\n    };\n  },\n\n  // Accept either a single view or an array of views to clean of all DOM\n  // events internal model and collection references and all Backbone.Events.\n  cleanViews: function(views) {\n    // Clear out all existing views.\n    _.each([].concat(views), function(view) {\n      // Remove all custom events attached to this View.\n      view.unbind();\n\n      // Ensure all nested views are cleaned as well.\n      if (view.views) {\n        _.each(view.views, function(view) {\n          LayoutManager.cleanViews(view);\n        });\n      }\n\n      // If a custom cleanup method was provided on the view, call it after\n      // the initial cleanup is done\n      if (_.isFunction(view.cleanup)) {\n        view.cleanup.call(view);\n      }\n    });\n  },\n\n  // Cache templates into LayoutManager._cache.\n  cache: function(path, contents) {\n    // If template path is found in the cache, return the contents.\n    if (path in this._cache) {\n      return this._cache[path];\n    // Ensure path and contents aren't undefined.\n    } else if (path != null && contents != null) {\n      return this._cache[path] = contents;\n    }\n\n    // If the template is not in the cache, return undefined.\n  },\n\n  // This static method allows for global configuration of LayoutManager.\n  configure: function(opts) {\n    _.extend(LayoutManager.prototype.options, opts);\n\n    // Allow LayoutManager to manage Backbone.View.prototype.\n    if (opts.manage) {\n      Backbone.View.prototype.manage = true;\n    }\n  },\n\n  // Configure a View to work with the LayoutManager plugin.\n  setupView: function(view, options) {\n    var views, viewOptions;\n    var proto = Backbone.LayoutManager.prototype;\n    var viewOverrides = _.pick(view, keys);\n\n    // If the View has already been setup, no need to do it again.\n    if (view.__manager__) {\n      return;\n    }\n\n    // Ensure necessary properties are set.\n    _.defaults(view, {\n      // Ensure a view always has a views object.\n      views: {},\n\n      // Internal state object used to store whether or not a View has been\n      // taken over by layout manager and if it has been rendered into the DOM.\n      __manager__: {},\n\n      // Add options into the prototype.\n      _options: LayoutManager.prototype._options,\n\n      // Add the ability to remove all Views.\n      _removeView: LayoutManager._removeView\n    });\n\n    // Set the prefix for a layout.\n    if (view instanceof Backbone.Layout) {\n      view.__manager__.prefix = view._options().paths.layout || \"\";\n    // Set the prefix for a template.\n    } else {\n      view.__manager__.prefix = view._options().paths.template || \"\";\n    }\n\n    // Extend the options with the prototype and passed options.\n    options = view.options = _.defaults(options || {}, view.options,\n      proto.options);\n\n    // Ensure view events are properly copied over.\n    viewOptions = _.pick(options, [\"events\"].concat(_.values(options.events)));\n    _.extend(view, viewOptions);\n\n    // If the View still has the Backbone.View#render method, remove it.  Don't\n    // want it accidentally overriding the LM render.\n    delete viewOverrides.render;\n\n    // Pick out the specific properties that can be dynamically added at\n    // runtime and ensure they are available on the view object.\n    _.extend(options, viewOverrides);\n\n    // By default the original Remove function is the Backbone.View one.\n    view._remove = Backbone.View.prototype.remove;\n\n    // Always use this render function when using LayoutManager.\n    view._render = function(manage) {\n      var renderDeferred;\n      // Cache these properties.\n      var beforeRender = this._options().beforeRender;\n      var afterRender = this._options().afterRender;\n\n      // Ensure all subViews are properly scrubbed.\n      this._removeView();\n\n      // If a beforeRender function is defined, call it.\n      if (_.isFunction(beforeRender)) {\n        beforeRender.call(this, this);\n      }\n\n      // Always emit a beforeRender event.\n      this.trigger(\"beforeRender\", this);\n\n      // Render!\n      renderDeferred = manage(this).render();\n\n      // Once rendering is complete...\n      renderDeferred.then(function() {\n        // Keep the view consistent between callbacks and deferreds.\n        var view = this;\n        // Shorthand the manager.\n        var manager = view.__manager__;\n        // Shorthand the View's parent.\n        var parent = manager.parent;\n        // This can be called immediately if the conditions allow, or it will\n        // be deferred until a parent has finished rendering.\n        var done = function() {\n          // Ensure events are always correctly bound after rendering.\n          view.delegateEvents();\n\n          // Set the view hasRendered.\n          view.__manager__.hasRendered = true;\n\n          // If an afterRender function is defined, call it.\n          if (_.isFunction(afterRender)) {\n            afterRender.call(view, view);\n          }\n\n          // Always emit an afterRender event.\n          view.trigger(\"afterRender\", view);\n        };\n        // This function recursively loops through Views to find\n        // the most top level parent.\n        var findRootParent = function(view) {\n          var manager = view.__manager__;\n\n          // If a parent exists, recurse.\n          if (manager.parent && !manager.hasRendered) {\n            return findRootParent(manager.parent);\n          }\n\n          // This is the most root parent.\n          return view;\n        };\n\n        // If no parent exists, immediately call the done callback.\n        if (!parent) {\n          return done.call(view);\n        }\n\n        // If this view has already rendered, simply call the callback.\n        if (parent.__manager__.hasRendered) {\n          return options.when([manager.viewDeferred, parent.__manager__.viewDeferred]).then(function() {\n            done.call(view);\n          });\n        }\n\n        parent = findRootParent(view);\n\n        // Once the parent has finished rendering, trickle down and\n        // call sub-view afterRenders.\n        parent.on(\"afterRender\", function() {\n          // Ensure its properly unbound immediately.\n          parent.off(null, null, view);\n\n          // Call the done callback.\n          done.call(view);\n        }, view);\n      });\n      return renderDeferred;\n    };\n\n    // Ensure the render is always set correctly.\n    view.render = LayoutManager.prototype.render;\n\n    // If the user provided their own remove override, use that instead of the\n    // default.\n    if (view.remove !== proto.remove) {\n      view._remove = view.remove;\n      view.remove = proto.remove;\n    }\n    \n    // Normalize views to exist on either instance or options, default to\n    // options.\n    views = options.views || view.views;\n\n    // Set the internal views, only if selectors have been provided.\n    if (_.keys(views).length) {\n      view.setViews(views);\n    }\n\n    // Ensure the template is mapped over.\n    if (view.template) {\n      options.template = view.template;\n\n      // Remove it from the instance.\n      delete view.template;\n    }\n  },\n\n  // Remove all subViews.\n  _removeView: function(root) {\n    // Allow removeView to be called on instances.\n    root = root || this;\n\n    // Iterate over all of the view's subViews.\n    root.getViews().each(function(view) {\n      // Shorthand the manager for easier access.\n      var manager = view.__manager__;\n      // Test for keep.\n      var keep = _.isBoolean(view.keep) ? view.keep : view.options.keep;\n\n      // Only remove views that do not have `keep` attribute set.\n      if (!keep && manager.append === true && manager.hasRendered) {\n        // Remove the View completely.\n        view.remove();\n\n        // If this is an array of items remove items that are not marked to\n        // keep.\n        if (_.isArray(manager.parent.views[manager.selector])) {\n          // Remove directly from the Array reference.\n          return manager.parent.getView(function(view, i) {\n            // If the selectors match, splice off this View.\n            if (view.__manager__.selector === manager.selector) {\n              manager.parent.views[manager.selector].splice(i, 1);\n            }\n          });\n        }\n\n        // Otherwise delete the parent selector.\n        delete manager.parent[manager.selector];\n      }\n    });\n  }\n});\n\n// Ensure all Views always have access to get/set/insert(View/Views).\n_.each([\"get\", \"set\", \"insert\"], function(method) {\n  var backboneProto = Backbone.View.prototype;\n  var layoutProto = LayoutManager.prototype;\n\n  // Attach the singular form.\n  backboneProto[method + \"View\"] = layoutProto[method + \"View\"];\n\n  // Attach the plural form.\n  backboneProto[method + \"Views\"] = layoutProto[method + \"Views\"];\n});\n\n// Convenience assignment to make creating Layout's slightly shorter.\nBackbone.Layout = Backbone.LayoutManager = LayoutManager;\n// A LayoutView is just a Backbone.View with manage set to true.\nBackbone.LayoutView = Backbone.View.extend({\n  manage: true\n});\n\n// Override _configure to provide extra functionality that is necessary in\n// order for the render function reference to be bound during initialize.\nBackbone.View.prototype._configure = function() {\n  // Run the original _configure.\n  var retVal = _configure.apply(this, arguments);\n\n  // If manage is set, do it!\n  if (this.manage) {\n    // Set up this View.\n    LayoutManager.setupView(this);\n  }\n\n  // Act like nothing happened.\n  return retVal;\n};\n\n// Default configuration options; designed to be overriden.\nLayoutManager.prototype.options = {\n  // Layout and template properties can be assigned here to prefix\n  // template/layout names.\n  paths: {},\n\n  // Can be used to supply a different deferred implementation.\n  deferred: function() {\n    return $.Deferred();\n  },\n\n  // Fetch is passed a path and is expected to return template contents as a\n  // function or string.\n  fetch: function(path) {\n    return _.template($(path).html());\n  },\n\n  // This is really the only way you will want to partially apply a view into\n  // a layout.  Its entirely possible you'll want to do it differently, so\n  // this method is available to change.\n  partial: function(root, name, el, append) {\n    // If no selector is specified, assume the parent should be added to.\n    var $root = name ? $(root).find(name) : $(root);\n\n    // If no root found, return false.\n    if (!$root.length) {\n      return false;\n    }\n\n    // Use the append method if append argument is true.\n    this[append ? \"append\" : \"html\"]($root, el);\n\n    // If successfully added, return true.\n    return true;\n  },\n\n  // Override this with a custom HTML method, passed a root element and an\n  // element to replace the innerHTML with.\n  html: function(root, el) {\n    $(root).html(el);\n  },\n\n  // Very similar to HTML except this one will appendChild.\n  append: function(root, el) {\n    $(root).append(el);\n  },\n\n  // Return a deferred for when all promises resolve/reject.\n  when: function(promises) {\n    return $.when.apply(null, promises);\n  },\n\n  // By default, render using underscore's templating.\n  render: function(template, context) {\n    return template(context);\n  }\n};\n\n// Maintain a list of the keys at define time.\nkeys = _.keys(LayoutManager.prototype.options);\n\n})(this);\n"]}